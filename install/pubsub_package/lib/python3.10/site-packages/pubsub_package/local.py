#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import rclpy
from rclpy.node import Node
from tf2_ros import TransformListener, Buffer
from tf2_ros import TransformException

# 修正：do_transform_pose 可能在某些版本需要显式导入，但 PoseStamped 必须来自 geometry_msgs
try:
    from tf2_geometry_msgs import do_transform_pose
except ImportError:
    import tf2_geometry_msgs

from geometry_msgs.msg import PoseStamped, Twist, Point
from scipy.spatial.transform import Rotation as R
import math
import time
import numpy as np
from nav_msgs.msg import Path
from sensor_msgs.msg import LaserScan
from visualization_msgs.msg import Marker # 修正：确保导入 Marker
from threading import Lock, Thread

# Import your own planner
from pubsub_package.planner.dwa import DWA

class LocalPlanner(Node):
    def __init__(self, real=None):
        super().__init__('local_planner')
        self.declare_parameter('real', True)
        self.declare_parameter('lookahead_dist', 0.8)
        self.declare_parameter('local_path_max_points', 30)
        self.declare_parameter('controller_frequency', 10.0)
        self.declare_parameter('rotate_to_goal', True)
        self.declare_parameter('yaw_goal_tolerance', 0.3)
        # DWA 参数
        self.declare_parameter('dwa.to_goal_cost_gain', 0.5)
        self.declare_parameter('dwa.path_cost_gain', 2.0)
        self.declare_parameter('dwa.heading_cost_gain', 0.3)
        self.declare_parameter('dwa.obstacle_cost_gain', 1.0)
        self.declare_parameter('dwa.speed_cost_gain', 0.2)
        self.declare_parameter('dwa.predict_time', 2.0)
        self.declare_parameter('dwa.v_samples', 6)
        self.declare_parameter('dwa.w_samples', 12)

        if real is None:
            real = bool(self.get_parameter('real').value)
        self.real = real
        
        self.x = 0.0
        self.y = 0.0
        self.yaw = 0.0
        self.vx = 0.0
        self.vw = 0.0
        
        self.path = Path()
        self.arrive = 0.2
        self.threshold = 1.5
        self.robot_size = 0.2
        self.V_X = 0.5
        self.V_W = 0.5

        # 初始化 DWA
        self.planner = DWA()
        self.planner.config(max_speed=self.V_X, max_yawrate=self.V_W, base=self.robot_size)
        self.planner.to_goal_cost_gain = float(self.get_parameter('dwa.to_goal_cost_gain').value)
        self.planner.path_cost_gain = float(self.get_parameter('dwa.path_cost_gain').value)
        self.planner.heading_cost_gain = float(self.get_parameter('dwa.heading_cost_gain').value)
        self.planner.obstacle_cost_gain = float(self.get_parameter('dwa.obstacle_cost_gain').value)
        self.planner.speed_cost_gain = float(self.get_parameter('dwa.speed_cost_gain').value)
        self.planner.predict_time = float(self.get_parameter('dwa.predict_time').value)
        self.planner.v_samples = int(self.get_parameter('dwa.v_samples').value)
        self.planner.w_samples = int(self.get_parameter('dwa.w_samples').value)

        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)

        self.path_sub = self.create_subscription(Path, '/course_agv/global_path', self.path_callback, 1)
        self.midpose_pub = self.create_publisher(PoseStamped, '/course_agv/mid_goal', 1)
        
        # 新增：发布可视化障碍物点
        self.marker_pub = self.create_publisher(Marker, '/course_agv/debug/obstacles', 1)

        if self.real:
            self.laser_sub = self.create_subscription(LaserScan, '/scan', self.laser_callback, 1)
            self.vel_pub = self.create_publisher(Twist, '/cmd_vel', 1)
        else:
            self.laser_sub = self.create_subscription(LaserScan, '/course_agv/laser/scan', self.laser_callback, 1)
            self.vel_pub = self.create_publisher(Twist, '/course_agv/velocity', 1)

        self.planning_thread = None
        self.lock = Lock()
        self.laser_lock = Lock()

        self.traj_pub = self.create_publisher(Path, '/course_agv/trajectory', 1)
        self.traj = Path()
        self.traj.header.frame_id = 'map'

        self.lookahead_dist = float(self.get_parameter('lookahead_dist').value)
        self.local_path_max_points = int(self.get_parameter('local_path_max_points').value)
        self.controller_frequency = float(self.get_parameter('controller_frequency').value)
        self.rotate_to_goal = bool(self.get_parameter('rotate_to_goal').value)
        self.yaw_goal_tolerance = float(self.get_parameter('yaw_goal_tolerance').value)
        
        self.plan_path_points = []
        self.ob = []
        self.plan_ob = np.array([])

    def path_callback(self, msg):
        self.lock.acquire()
        self.path = msg
        self.update_global_pose(init=True)
        self.lock.release()
        
        if self.planning_thread is None:
            self.planning_thread = Thread(target=self.plan_thread_func)
            self.planning_thread.start()

    def plan_thread_func(self):
        self.get_logger().info("Running planning thread!")
        
        while rclpy.ok():
            self.lock.acquire()
            if len(self.path.poses) == 0:
                self.lock.release()
                time.sleep(0.1)
                continue
                
            self.plan_once()
            self.lock.release()
            
            time.sleep(1.0 / max(self.controller_frequency, 1.0))
            
            if self.goal_dis < self.arrive:
                self.lock.acquire()
                if self.rotate_to_goal and len(self.path.poses) >= 2:
                    p1 = self.path.poses[-2].pose.position
                    p2 = self.path.poses[-1].pose.position
                    yaw_des = math.atan2(p2.y - p1.y, p2.x - p1.x)
                    yaw_err = normalize_angle(yaw_des - self.yaw)
                    
                    if abs(yaw_err) > self.yaw_goal_tolerance:
                        self.vx = 0.0
                        self.vw = max(min(1.5 * yaw_err, self.V_W), -self.V_W)
                        self.publish_velocity(zero=False)
                        self.lock.release()
                        continue

                self.publish_velocity(zero=True)
                self.lock.release()
                self.get_logger().info("Arrived at goal!")
                break
                
        self.planning_thread = None
        self.get_logger().info("Exiting planning thread!")

    def plan_once(self):
        self.update_global_pose(init=False)
        self.update_obstacle()
        self.publish_obstacles() 

        pose_robot_frame = (0.0, 0.0, 0.0)
        velocity = (self.vx, self.vw)

        u = self.planner.planning(
            pose=pose_robot_frame, 
            velocity=velocity, 
            goal=self.plan_goal, 
            points_cloud=self.plan_ob.tolist(),
            path_points=self.plan_path_points,
        )

        self.vx = max(min(u[0], self.V_X), -self.V_X)
        self.vw = max(min(u[1], self.V_W), -self.V_W)
        
        self.get_logger().info(f"v: {self.vx:.2f}, w: {self.vw:.2f}")
        self.publish_velocity(zero=False)

    def publish_obstacles(self):
        """将 DWA 使用的障碍物点以 Marker 形式发布到 Rviz"""
        if len(self.plan_ob) == 0:
            return
            
        marker = Marker()
        marker.header.frame_id = "base_footprint" 
        marker.header.stamp = self.get_clock().now().to_msg()
        marker.ns = "dwa_obstacles"
        marker.id = 0
        marker.type = Marker.POINTS
        marker.action = Marker.ADD
        marker.scale.x = 0.05 
        marker.scale.y = 0.05
        marker.color.a = 1.0
        marker.color.r = 1.0 
        marker.color.g = 0.0
        marker.color.b = 0.0
        
        for p in self.plan_ob:
            pt = Point()
            pt.x = float(p[0])
            pt.y = float(p[1])
            pt.z = 0.0
            marker.points.append(pt)
            
        self.marker_pub.publish(marker)

    def update_global_pose(self, init=False):
        try:
            trans = self.tf_buffer.lookup_transform(
                'map', 
                'base_footprint', 
                rclpy.time.Time(), 
                rclpy.duration.Duration(seconds=0.1)
            )

            self.x = trans.transform.translation.x
            self.y = trans.transform.translation.y

            rotation = R.from_quat([
                trans.transform.rotation.x,
                trans.transform.rotation.y,
                trans.transform.rotation.z,
                trans.transform.rotation.w
            ])
            self.yaw = rotation.as_euler('xyz', degrees=False)[2]

        except TransformException:
            self.get_logger().debug("TF lookup failed, using previous pose")
            return

        pose = PoseStamped()
        pose.header.frame_id = 'map'
        pose.header.stamp = self.get_clock().now().to_msg()
        pose.pose.position.x = self.x
        pose.pose.position.y = self.y
        pose.pose.orientation.w = 1.0 
        
        self.traj.header.stamp = self.get_clock().now().to_msg()
        self.traj.poses.append(pose)
        
        if len(self.traj.poses) > 1000:
            self.traj.poses.pop(0)
            
        self.traj_pub.publish(self.traj)

        if init:
            self.goal_index = 0
            self.traj.poses = [] 

        if len(self.path.poses) < 2:
            return

        pts = np.array(
            [[p.pose.position.x, p.pose.position.y] for p in self.path.poses],
            dtype=float,
        )
        d2 = (pts[:, 0] - self.x) ** 2 + (pts[:, 1] - self.y) ** 2
        nearest = int(np.argmin(d2))

        goal_index = min(nearest + 1, len(self.path.poses) - 1)
        acc = 0.0
        for i in range(nearest, len(self.path.poses) - 1):
            seg = math.hypot(pts[i + 1, 0] - pts[i, 0], pts[i + 1, 1] - pts[i, 1])
            acc += seg
            if acc >= self.lookahead_dist:
                goal_index = i + 1
                break

        self.goal_index = goal_index
        goal = self.path.poses[self.goal_index]
        self.midpose_pub.publish(goal)

        try:
            lgoal = self.tf_buffer.transform(goal, 'base_footprint')
            self.plan_goal = (lgoal.pose.position.x, lgoal.pose.position.y)
        except Exception:
            self.plan_goal = (1.0, 0.0) 

        local_pts = []
        end = min(nearest + max(self.local_path_max_points, 2), len(self.path.poses))
        for i in range(nearest, end):
            try:
                lp = self.tf_buffer.transform(self.path.poses[i], 'base_footprint')
                local_pts.append((lp.pose.position.x, lp.pose.position.y))
            except Exception:
                continue
        self.plan_path_points = local_pts

        self.goal_dis = math.hypot(
            self.x - self.path.poses[-1].pose.position.x,
            self.y - self.path.poses[-1].pose.position.y,
        )

    def laser_callback(self, msg):
        self.laser_lock.acquire()
        self.ob = []
        angle_min = msg.angle_min
        angle_increment = msg.angle_increment
        for i, r in enumerate(msg.ranges):
            if not (msg.range_min <= r <= msg.range_max):
                continue
            a = angle_min + angle_increment * i
            if r < self.threshold:
                self.ob.append((math.cos(a) * r, math.sin(a) * r))
        self.laser_lock.release()

    def update_obstacle(self):
        self.laser_lock.acquire()
        if len(self.ob) > 0:
            self.plan_ob = np.array(self.ob)
        else:
            self.plan_ob = np.empty((0, 2))
        self.laser_lock.release()

    def publish_velocity(self, zero=False):
        if zero:
            self.vx = 0.0
            self.vw = 0.0
        cmd = Twist()
        cmd.linear.x = float(self.vx)
        cmd.angular.z = float(self.vw)
        self.vel_pub.publish(cmd)


def normalize_angle(angle):
    while angle > math.pi:
        angle -= 2 * math.pi
    while angle < -math.pi:
        angle += 2 * math.pi
    return angle


def main(args=None):
    rclpy.init(args=args)
    local_planner = LocalPlanner()
    rclpy.spin(local_planner)
    local_planner.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()